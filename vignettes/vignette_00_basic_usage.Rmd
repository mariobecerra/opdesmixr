---
title: "Basic usage"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vignette_00_basic_usage}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache = T, 
  fig.width = 8
)
```


```{r setup}
library(opdesmixr)
library(tidyr)
library(ggplot2)
```

# Plot Cox direction

```{r}

##########################################################
##########################################################
## Tests functions common to both models
##########################################################
##########################################################

x_in = c(0.4725440, 0.2627838, 0.2646722)
plot_cox_direction(x_in, 1)
plot_cox_direction(x_in, 1:3)

plot_cox_direction(c(1, 0, 0), 1:3)
plot_cox_direction(c(0, 1, 0), 1:3)
plot_cox_direction(c(0, 0, 1), 1:3)


# plot several Cox's directions for random designs
# Don't understand why the plots are not right when arranged in a grid with gridExtra
# I need to use ggtern's own grid.arrange
# https://stackoverflow.com/questions/42825983/issue-when-using-grid-arrange-with-ggtern-generated-plots
# do.call("grid.arrange", c(cox_direction_plots, ncol = 4)) # This works with ggtern::grid.arrange
random_designs = gaussian_create_random_initial_design(8, q = 3, seed = 1)

cox_direction_plots = lapply(1:nrow(random_designs), function(i){
  return(plot_cox_direction(random_designs[i,], 1:3))
})

ggtern::grid.arrange(grobs = cox_direction_plots, ncol = 4)


```

Detect number of cores.

```{r}
n_cores = parallel::detectCores()
```

# Normal Scheffé mixture models

Create a D-optimal and an I-optimal design for a special-cubic Scheffé model with 30 runs and 3 ingredients using 100 initial random designs. On the left side we see the initial random design and on the right the optimal one.

### D-optimality

```{r}

d_opt_des = gaussian_mixture_coord_exch(
  n_runs = 30, 
  q = 3, 
  n_random_starts = 100,
  order = 3, 
  opt_crit = "D",
  plot_designs = T,
  verbose = 0,
  n_cores = n_cores)

```

### I-optimality

```{r}

i_opt_des = gaussian_mixture_coord_exch(
  n_runs = 30, 
  q = 3, 
  n_random_starts = 100,
  order = 3, 
  opt_crit = "I",
  plot_designs = T,
  verbose = 0,
  n_cores = n_cores)

```


# Pseudo-Bayesian designs

```{r}

library(randtoolbox)




q = 3
J = 5
S = 4
X4 = mnl_create_random_initial_design(q, J, S, seed = 3)
beta4_2 = create_random_beta(q)






draws_unif_beta4_2 = halton(120, dim = length(beta4_2$beta))

beta4_2_prior_draws = matrix(rep(NA_real_, length(draws_unif_beta4_2)), ncol = ncol(draws_unif_beta4_2))
for(i in 1:ncol(beta4_2_prior_draws)){
  beta4_2_prior_draws[, i] = qnorm(draws_unif_beta4_2[, i], beta4_2$beta[i], 3)
}


beta4_2_prior_draws %>%
  as.data.frame() %>%
  pivot_longer(starts_with("V")) %>%
  ggplot() +
  geom_density(aes(value)) +
  facet_wrap(~name)





# 25 secs
X_q3_J5_s4_D_bayes = mnl_mixture_coord_exch(
  n_random_starts = 8,
  q = q,
  J = J,
  S = S,
  beta = beta4_2_prior_draws,
  n_cox_points = 20,
  max_it = 4,
  verbose = 1,
  plot_designs = T,
  n_cores = 4,
  seed = 10,
  opt_crit = "D",
  opt_method = "D"
)





# 16 seconds
X_q3_J5_s4_D_bayes = mnl_mixture_coord_exch(
  n_random_starts = 8,
  q = q,
  J = J,
  S = S,
  beta = beta4_2_prior_draws,
  n_cox_points = 20,
  max_it = 4,
  verbose = 1,
  plot_designs = T,
  n_cores = 4,
  seed = 10,
  opt_crit = "D",
  opt_method = "B"
)



```




