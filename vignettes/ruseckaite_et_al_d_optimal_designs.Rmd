---
title: "Comparing designs with Ruseckaite et. al"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ruseckaite_et_al_d_optimal_designs}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache = T, 
  fig.width = 8,
  fig.height = 10
)
```

```{r setup}
library(opdesmixr)
library(tidyverse)

# Original Ruseckaite et. al designs:
# https://rss.onlinelibrary.wiley.com/action/downloadSupplement?doi=10.1111%2Frssc.12174&file=rssc12174-sup-0001-Appendix.pdf


ruseckaite_designs_folder = opdesmixr:::get_file_path_inst("exdata/")
ruseckaite_cocktail_designs = read_csv(paste0(ruseckaite_designs_folder, "/ruseckaite_cocktail_designs.csv"))
ruseckaite_cornell_designs = read_csv(paste0(ruseckaite_designs_folder, "/ruseckaite_cornell_designs.csv"))


designs_folder = opdesmixr:::get_file_path_inst("misc_output/cocktail_cornell_designs/")

n_cores = parallel::detectCores()
utility_point_size = 0.1

```

# Cocktail experiment

```{r}
ruseckaite_beta0_design = mnl_design_dataframe_to_array(
  ruseckaite_cocktail_designs %>%
    filter(prior == "beta_0 and sigma_0") %>%
    select(-prior)
)


q = 3
J = 2
S = 16
n_draws = 128

m = (q^3 + 5*q)/6

beta0 = c(1.36, 1.57, 2.47, -0.43, 0.50, 1.09)

sigma0 = matrix(
  c(6.14, 5.00, 2.74, -0.43, -2.81, -3.33,
    5.00, 6.76, 4.47, -1.79, -6.13, -3.51,
    2.74, 4.47, 3.45, -1.38, -4.71, -2.17,
    -0.43, -1.79, -1.38, 1.18, 2.39, 0.71,
    -2.81, -6.13, -4.71, 2.39, 7.43, 2.71,
    -3.33, -3.51, -2.17, 0.71, 2.71, 2.49),
  ncol = 6,
  byrow = T)

beta_correlated_draws_cocktail = get_correlated_halton_draws(beta0, sigma0, n_draws)


n_rand_starts = 40
max_it = 10
seed = 2020


cocktail_d_opt_filename = paste0(designs_folder, "cocktail_d_optimal.rds")
cocktail_i_opt_filename = paste0(designs_folder, "cocktail_i_optimal.rds")

##########################################################################################
#### Load or create the designs
##########################################################################################

if(file.exists(cocktail_d_opt_filename)){
  cocktail_D_opt = readRDS(cocktail_d_opt_filename)
} else{
  # 10 mins
  (t1D = Sys.time())
  cocktail_D_opt = mnl_mixture_coord_exch(
    n_random_starts = n_rand_starts,
    q = q,
    J = J,
    S = S,
    beta = beta_correlated_draws_cocktail,
    transform_beta = F,
    opt_method = "B",
    opt_crit = "D",
    max_it = max_it,
    verbose = 1,
    plot_designs = F,
    seed = seed,
    n_cores = n_cores
  )
  (t2D = Sys.time())
  t2D - t1D
  
  saveRDS(cocktail_D_opt, cocktail_d_opt_filename)
}



if(file.exists(cocktail_i_opt_filename)){
  cocktail_I_opt = readRDS(cocktail_i_opt_filename)
} else{
  # 14 mins
  (t1I = Sys.time())
  cocktail_I_opt =  mnl_mixture_coord_exch(
    n_random_starts = n_rand_starts,
    q = q,
    J = J,
    S = S,
    beta = beta_correlated_draws_cocktail,
    transform_beta = F,
    opt_method = "B",
    opt_crit = "I",
    max_it = max_it,
    verbose = 1,
    plot_designs = F,
    seed = seed,
    n_cores = n_cores
  )
  (t2I = Sys.time())
  t2I - t1I
  
  saveRDS(cocktail_I_opt, cocktail_i_opt_filename)
}


##########################################################################################
#### Create the utility surface dataframe used for plotting
##########################################################################################

levels_cocktail_bayesian = c(0, .5625, 1.125, 1.6875, 2.25)
utilities_cocktail_bayesian_plot = opdesmixr:::scheffe_order3_q3_utilities(beta0, 50000) %>%
  mutate(utility_fact = cut(utility, levels_cocktail_bayesian, right = F)) %>%
  mutate(utility_int = as.integer(utility_fact)) %>%
  mutate(utility_avg = case_when(
    utility_int == 1 ~ (levels_cocktail_bayesian[1] + levels_cocktail_bayesian[2] - levels_cocktail_bayesian[1])/2,
    utility_int == 2 ~ (levels_cocktail_bayesian[2] + levels_cocktail_bayesian[3] - levels_cocktail_bayesian[2])/2,
    utility_int == 3 ~ (levels_cocktail_bayesian[3] + levels_cocktail_bayesian[4] - levels_cocktail_bayesian[3])/2,
    utility_int == 4 ~ (levels_cocktail_bayesian[4] + levels_cocktail_bayesian[5] - levels_cocktail_bayesian[4])/2
  ))

```

```{r, fig.height=7, fig.width=10}

##########################################################################################
#### Plot designs
##########################################################################################

# Halton draws of the prior for evaluating Bayesian D and I optimality
beta_correlated_draws_cocktail_plot = get_correlated_halton_draws(beta0, sigma0, 5000)

suppressWarnings(
  ggtern::grid.arrange(
    opdesmixr:::plot_choice_set_utility(
      ruseckaite_beta0_design, 
      utilities_cocktail_bayesian_plot,
      utility_point_size = utility_point_size) +
      ggtitle(
        "Ruseckaite's Bayesian D-optimal design",
        subtitle = paste0(
          "D-opt value: ", round(
            mnl_get_opt_crit_value(
              X = ruseckaite_beta0_design,
              beta = beta_correlated_draws_cocktail_plot,
              order = 3,
              opt_crit = "D",
              transform_beta = F), 
            2),
          
          "  I-opt value: ", round(
            mnl_get_opt_crit_value(
              X = ruseckaite_beta0_design,
              beta = beta_correlated_draws_cocktail_plot,
              order = 3,
              opt_crit = "I",
              transform_beta = F), 
            2)
        )
      )
    ,
    
    opdesmixr:::plot_choice_set_utility(
      cocktail_D_opt, 
      utilities_cocktail_bayesian_plot,
      utility_point_size = utility_point_size) +
      ggtitle(
        "Bayesian D-optimal design",
        subtitle = paste0(
          "D-opt value: ", round(
            mnl_get_opt_crit_value(
              X = cocktail_D_opt$X,
              beta = beta_correlated_draws_cocktail_plot,
              order = 3,
              opt_crit = "D",
              transform_beta = F), 
            2),
          
          "  I-opt value: ", round(
            mnl_get_opt_crit_value(
              X = cocktail_D_opt$X,
              beta = beta_correlated_draws_cocktail_plot,
              order = 3,
              opt_crit = "I",
              transform_beta = F), 
            2)
        )
      )
    ,
    
    opdesmixr:::plot_choice_set_utility(
      cocktail_I_opt, 
      utilities_cocktail_bayesian_plot,
      utility_point_size = utility_point_size) +
      ggtitle(
        "Bayesian I-optimal design",
        subtitle = paste0(
          "D-opt value: ", round(
            mnl_get_opt_crit_value(
              X = cocktail_I_opt$X,
              beta = beta_correlated_draws_cocktail_plot,
              order = 3,
              opt_crit = "D",
              transform_beta = F), 
            2),
          
          "  I-opt value: ", round(
            mnl_get_opt_crit_value(
              X = cocktail_I_opt$X,
              beta = beta_correlated_draws_cocktail_plot,
              order = 3,
              opt_crit = "I",
              transform_beta = F), 
            2)
        ))
    ,
    ncol = 3
  )
)
```

```{r}

n_points_per_alternative_cocktail = 500
beta_correlated_draws_cocktail_plot_2 = get_correlated_halton_draws(beta0, sigma0, 500)




pred_vars_cocktail = mnl_get_fds_simulations(
  design_array = cocktail_I_opt$X,
  beta = beta_correlated_draws_cocktail_plot_2,
  order = 3,
  n_points_per_alternative = n_points_per_alternative_cocktail,
  transform_beta = F,
  verbose = 0) %>%
  mutate(Design = "I-optimal") %>%
  bind_rows(
    mnl_get_fds_simulations(
      design_array = cocktail_D_opt$X,
      beta = beta_correlated_draws_cocktail_plot_2,
      order = 3,
      n_points_per_alternative = n_points_per_alternative_cocktail,
      transform_beta = F,
      verbose = 0) %>%
      mutate(Design = "D-optimal")
  ) %>% 
  bind_rows(
    mnl_get_fds_simulations(
      design_array = ruseckaite_beta0_design,
      beta = beta_correlated_draws_cocktail_plot_2,
      order = 3,
      n_points_per_alternative = n_points_per_alternative_cocktail,
      transform_beta = F,
      verbose = 0) %>%
      mutate(Design = "Ruseckaite")
  )




pred_vars_cocktail %>%
  ggplot() +
  geom_vline(xintercept = 0.5, linetype = "dashed", size = 0.2) +
  geom_hline(yintercept = pred_vars_cocktail %>%
               group_by(Design) %>%
               summarize(
                 med = median(pred_var),
                 mean = mean(pred_var)) %>%
               pull(med),
             linetype = "dashed", size = 0.2) +
  geom_line(aes(fraction, pred_var, linetype = Design, color = Design), size = 0.8) +
  xlab("Fraction of design space") +
  ylab("Prediction variance") +
  ggtitle("Cocktail experiment") +
  theme_bw() +
  theme(legend.position = "right")

```





# Cornell experiment

```{r}
n_cores = parallel::detectCores()
seed = 2020


# beta_0 = c(+11.25, +5.54, +3.73, +26.93, +20.52, +28.44, -180.68)
# beta_0_prime = c(+11.25 - 3.73, +5.54 - 3.73, +26.93, +20.52, +28.44, -180.68)
beta_1_prime = c(1.15, 0.28, 4.12, 3.14, 4.36, -27.67)
beta_2_prime = c(0.86, 0.21, 3.07, 2.34, 3.24, -20.59)
beta_2 = c(0.86, 0.21, 0, 3.07, 2.34, 3.24, -20.59)
```

```{r}

##########################################################################################
#### Create the utility surface dataframe used for plotting
##########################################################################################

levels_cornell_utilities_1 = c(0, 0.5, 1, 1.5, 1.8)
utilities_1 = opdesmixr:::scheffe_order3_q3_utilities(beta_1_prime, 50000) %>%
  mutate(utility_fact = cut(utility, levels_cornell_utilities_1, right = F)) %>%
  mutate(utility_int = as.integer(utility_fact)) %>%
  mutate(utility_avg = case_when(
    utility_int == 1 ~ (levels_cornell_utilities_1[1] + levels_cornell_utilities_1[2] - levels_cornell_utilities_1[1])/2,
    utility_int == 2 ~ (levels_cornell_utilities_1[2] + levels_cornell_utilities_1[3] - levels_cornell_utilities_1[2])/2,
    utility_int == 3 ~ (levels_cornell_utilities_1[3] + levels_cornell_utilities_1[4] - levels_cornell_utilities_1[3])/2,
    utility_int == 4 ~ (levels_cornell_utilities_1[4] + levels_cornell_utilities_1[5] - levels_cornell_utilities_1[4])/2
  ))




levels_cornell_utilities_2 = c(0, 0.375, 0.75, 1.125, 1.34)
utilities_2 = opdesmixr:::scheffe_order3_q3_utilities(beta_2_prime, 50000) %>%
  mutate(utility_fact = cut(utility, levels_cornell_utilities_2, right = F)) %>%
  mutate(utility_int = as.integer(utility_fact)) %>%
  mutate(utility_avg = case_when(
    utility_int == 1 ~ (levels_cornell_utilities_2[1] + levels_cornell_utilities_2[2] - levels_cornell_utilities_2[1])/2,
    utility_int == 2 ~ (levels_cornell_utilities_2[2] + levels_cornell_utilities_2[3] - levels_cornell_utilities_2[2])/2,
    utility_int == 3 ~ (levels_cornell_utilities_2[3] + levels_cornell_utilities_2[4] - levels_cornell_utilities_2[3])/2,
    utility_int == 4 ~ (levels_cornell_utilities_2[4] + levels_cornell_utilities_2[5] - levels_cornell_utilities_2[4])/2
  ))






levels_cornell_bayesian = c(0, 0.375, 0.75, 1.125, 1.33333)
utilities_cornell_bayesian_plot = opdesmixr:::scheffe_order3_q3_utilities(beta_2_prime, 50000) %>%
  mutate(utility_fact = cut(utility, levels_cornell_bayesian, right = F)) %>%
  mutate(utility_int = as.integer(utility_fact)) %>%
  mutate(utility_avg = case_when(
    utility_int == 1 ~ (levels_cornell_bayesian[1] + levels_cornell_bayesian[2] - levels_cornell_bayesian[1])/2,
    utility_int == 2 ~ (levels_cornell_bayesian[2] + levels_cornell_bayesian[3] - levels_cornell_bayesian[2])/2,
    utility_int == 3 ~ (levels_cornell_bayesian[3] + levels_cornell_bayesian[4] - levels_cornell_bayesian[3])/2,
    utility_int == 4 ~ (levels_cornell_bayesian[4] + levels_cornell_bayesian[5] - levels_cornell_bayesian[4])/2
  ))


```


### Locally optimal designs

```{r}

##########################################################################################
#### Compute locally optimal designs
##########################################################################################

# Each design takes between 30 to 40 seconds with 1000 random starts and 4 cores

n_random_starts_1 = 1000
max_it_local = 8


cornell_beta_1_locally_d_opt_filename = paste0(designs_folder, "cornell_beta_1_locally_d_opt.rds")
cornell_beta_2_locally_d_opt_filename = paste0(designs_folder, "cornell_beta_2_locally_d_opt.rds")
cornell_beta_1_locally_i_opt_filename = paste0(designs_folder, "cornell_beta_1_locally_i_opt.rds")
cornell_beta_2_locally_i_opt_filename = paste0(designs_folder, "cornell_beta_2_locally_i_opt.rds")


if(file.exists(cornell_beta_1_locally_d_opt_filename)){
  cornell_beta_1_locally_d_opt = readRDS(cornell_beta_1_locally_d_opt_filename)
  
}else{
  cornell_beta_1_locally_d_opt = mnl_mixture_coord_exch(
    q = 3,
    J = 2,
    S = 7,
    n_random_starts = n_random_starts_1,
    beta = beta_1_prime,
    transform_beta = F,
    max_it = max_it_local,
    n_cores = n_cores,
    opt_crit = "D",
    plot_designs = F,
    seed = seed)
  
  saveRDS(cornell_beta_1_locally_d_opt, cornell_beta_1_locally_d_opt_filename)
}


if(file.exists(cornell_beta_2_locally_d_opt_filename)){
  cornell_beta_2_locally_d_opt = readRDS(cornell_beta_2_locally_d_opt_filename)
}else{
  cornell_beta_2_locally_d_opt = mnl_mixture_coord_exch(
    q = 3,
    J = 2,
    S = 7,
    n_random_starts = n_random_starts_1,
    beta = beta_2_prime,
    transform_beta = F,
    max_it = max_it_local,
    n_cores = n_cores,
    opt_crit = "D",
    plot_designs = F,
    seed = seed)
  
  saveRDS(cornell_beta_2_locally_d_opt, cornell_beta_2_locally_d_opt_filename)
}


if(file.exists(cornell_beta_1_locally_i_opt_filename)){
  cornell_beta_1_locally_i_opt = readRDS(cornell_beta_1_locally_i_opt_filename)
}else{
  cornell_beta_1_locally_i_opt = mnl_mixture_coord_exch(
    q = 3,
    J = 2,
    S = 7,
    n_random_starts = n_random_starts_1,
    beta = beta_1_prime,
    transform_beta = F,
    max_it = max_it_local,
    n_cores = n_cores,
    opt_crit = "I",
    plot_designs = F)
  
  saveRDS(cornell_beta_1_locally_i_opt, cornell_beta_1_locally_i_opt_filename)
}


if(file.exists(cornell_beta_2_locally_i_opt_filename)){
  cornell_beta_2_locally_i_opt = readRDS(cornell_beta_2_locally_i_opt_filename)
}else{
  cornell_beta_2_locally_i_opt = mnl_mixture_coord_exch(
    q = 3,
    J = 2,
    S = 7,
    n_random_starts = n_random_starts_1,
    beta = beta_2_prime,
    transform_beta = F,
    max_it = max_it_local,
    n_cores = n_cores,
    opt_crit = "I",
    plot_designs = F)
  
  saveRDS(cornell_beta_2_locally_i_opt, cornell_beta_2_locally_i_opt_filename)
}

```

```{r, fig.height=10, fig.width=10}
##########################################################################################
#### Plot locally optimal designs
##########################################################################################


suppressWarnings(
  ggtern::grid.arrange(
    opdesmixr:::plot_choice_set_utility(cornell_beta_1_locally_d_opt, utilities_1, utility_point_size = utility_point_size) +
      ggtitle("Locally D-optimal beta 1")
    ,
    opdesmixr:::plot_choice_set_utility(cornell_beta_2_locally_d_opt, utilities_2, utility_point_size = utility_point_size) +
      ggtitle("Locally D-optimal beta 2")
    ,
    opdesmixr:::plot_choice_set_utility(cornell_beta_1_locally_i_opt, utilities_1, utility_point_size = utility_point_size) +
      ggtitle("Locally I-optimal beta 1")
    ,
    opdesmixr:::plot_choice_set_utility(cornell_beta_2_locally_i_opt, utilities_2, utility_point_size = utility_point_size) +
      ggtitle("Locally I-optimal beta 2")
    ,
    ncol = 2
  )
)
```


### Bayesian optimal designs

```{r}

kappas = c(0.5, 5, 10, 30)
n_draws = 128
n_random_starts_2 = 128
max_it_bayes = 20


# cornell_designs_basefilename = paste0(designs_folder, "cornell_experiment_rs", n_random_starts_2, "_maxit", max_it_bayes)
cornell_designs_basefilename = paste0(designs_folder, "cornell_experiment_untransformed_betas_rs", n_random_starts_2, "_maxit", max_it_bayes)


## Reading designs if they exist. Otherwise, creating and saving them.
(start_time = Sys.time())
cornell_designs = lapply(kappas, function(k){
  # Each design takes around 53 and 87 seconds with 16 initial random designs, 128 halton draws, 10 max iterations and 4 cores.
  # Each design takes around 99 and 160 seconds with 32 initial random designs, 128 halton draws, 10 max iterations and 4 cores.
  # Each design takes around 13 and 20 minutes with 128 initial random designs, 128 halton draws, 20 max iterations and 4 cores.
  
  cat("kappa =", k, "\n")
  
  beta_2_prior_draws = get_halton_draws(beta_2_prime, sd = sqrt(k), ndraws = n_draws)
  
  d_opt_filename = paste0(cornell_designs_basefilename, "_kappa", k, "_Dopt.rds")
  
  if(file.exists(d_opt_filename)){
    cat("\tD optimal file exists. Loading.\n")
    cornell_beta_2_pseudo_bayesian_d_opt = readRDS(d_opt_filename)
  }else{
    cat("\tD optimal file does not exist. Creating design.\n")
    cornell_beta_2_pseudo_bayesian_d_opt = mnl_mixture_coord_exch(
      q = 3,
      J = 2,
      S = 7,
      verbose = 1,
      n_random_starts = n_random_starts_2,
      beta = beta_2_prior_draws,
      transform_beta = F,
      max_it = max_it_bayes,
      n_cores = n_cores,
      opt_crit = "D",
      plot_designs = F)
    
    saveRDS(cornell_beta_2_pseudo_bayesian_d_opt, d_opt_filename)
  }
  
  
  i_opt_filename = paste0(cornell_designs_basefilename, "_kappa", k, "_Iopt.rds")
  
  if(file.exists(i_opt_filename)){
    cat("\tI optimal file exists. Loading.\n")
    cornell_beta_2_pseudo_bayesian_i_opt = readRDS(i_opt_filename)
  }else{
    cat("\tI optimal file does not exist. Creating design.\n")
    cornell_beta_2_pseudo_bayesian_i_opt = mnl_mixture_coord_exch(
      q = 3,
      J = 2,
      S = 7,
      verbose = 1,
      n_random_starts = n_random_starts_2,
      beta = beta_2_prior_draws,
      transform_beta = F,
      max_it = max_it_bayes,
      n_cores = n_cores,
      opt_crit = "I",
      plot_designs = F)
    
    saveRDS(cornell_beta_2_pseudo_bayesian_i_opt, i_opt_filename)
  }
  
  
  return(list(
    d_opt = cornell_beta_2_pseudo_bayesian_d_opt,
    i_opt = cornell_beta_2_pseudo_bayesian_i_opt,
    kappa = k
  ))
  
})
(end_time = Sys.time())
(end_time - start_time)



##########################################################################################
#### Compare previous designs with Ruseckaite's
##########################################################################################

# number of Halton draws to evaluate the design
n_draws_eval_design = 5000


# Ruseckaite's designs
ruseckaite_designs_list = lapply(unique(ruseckaite_cornell_designs$k), function(kappa){
  beta_prior_draws = get_halton_draws(beta_2_prime, sd = sqrt(kappa), ndraws = n_draws_eval_design)
  
  des_array_k = ruseckaite_cornell_designs %>%
    filter(k == kappa) %>%
    select(-k) %>%
    mnl_design_dataframe_to_array()
  
  
  d_opt_value = mnl_get_opt_crit_value(
    X = des_array_k,
    beta = beta_prior_draws,
    order = 3,
    opt_crit = "D",
    transform_beta = F)
  
  i_opt_value = mnl_get_opt_crit_value(
    X = des_array_k,
    beta = beta_prior_draws,
    order = 3,
    opt_crit = "I",
    transform_beta = F)
  
  
  info = tibble(
    kappa = kappa,
    d_opt_value = d_opt_value,
    i_opt_value = i_opt_value,
    type_design = "D_optimal",
    author = "Ruseckaite")
  
  
  out = list(
    design = des_array_k,
    info = info
  )
  
  
})



# My designs
mbc_designs_list = lapply(1:(length(cornell_designs)*2), function(j){
  
  if(j %% 2 == 1) { # j is odd
    i = (j-1)/2 + 1
    
    kappa = cornell_designs[[i]]$kappa
    beta_prior_draws = get_halton_draws(beta_2_prime, sd = sqrt(kappa), ndraws = n_draws_eval_design)
    
    d_opt_value_doptdes = mnl_get_opt_crit_value(
      X = cornell_designs[[i]]$d_opt$X,
      beta = beta_prior_draws,
      order = 3,
      opt_crit = "D",
      transform_beta = F)
    
    i_opt_value_doptdes = mnl_get_opt_crit_value(
      X = cornell_designs[[i]]$d_opt$X,
      beta = beta_prior_draws,
      order = 3,
      opt_crit = "I",
      transform_beta = F)
    
    info = tibble(
      kappa = kappa,
      d_opt_value = c(d_opt_value_doptdes),
      i_opt_value = c(i_opt_value_doptdes),
      type_design = c("D_optimal"),
      author = "Becerra"
    )
    
    out = list(
      design = cornell_designs[[i]]$d_opt$X,
      info = info
    )
    
  } else{ # j is even
    i = j/2
    
    kappa = cornell_designs[[i]]$kappa
    beta_prior_draws = get_halton_draws(beta_2_prime, sd = sqrt(kappa), ndraws = n_draws_eval_design)
    
    d_opt_value_ioptdes = mnl_get_opt_crit_value(
      X = cornell_designs[[i]]$i_opt$X,
      beta = beta_prior_draws,
      order = 3,
      opt_crit = "D",
      transform_beta = F)
    
    i_opt_value_ioptdes = mnl_get_opt_crit_value(
      X = cornell_designs[[i]]$i_opt$X,
      beta = beta_prior_draws,
      order = 3,
      opt_crit = "I",
      transform_beta = F)
    
    
    info = tibble(
      kappa = kappa,
      d_opt_value = c(d_opt_value_ioptdes),
      i_opt_value = c(i_opt_value_ioptdes),
      type_design = c("I_optimal"),
      author = "Becerra"
    )
    
    out = list(
      design = cornell_designs[[i]]$i_opt$X,
      info = info
    )
    
  }
})


# Create a list with all the designs
all_designs = c(ruseckaite_designs_list, mbc_designs_list)

# Create a single dataframe with the information of each design
all_designs_optimality_values = map_df(seq_along(all_designs), function(i){
  out = all_designs[[i]]$info %>%
    mutate(index_in_list = i)
  
  return(out)
}) %>%
  arrange(kappa, type_design, desc(author))

all_designs_optimality_values


```

```{r, , fig.height=20, fig.width=10}

## Create a list with the plots of the optimal designs
optimal_designs_plots = all_designs_optimality_values %>%
  # filter(type_design == "D_optimal") %>%
  pull(index_in_list) %>%
  lapply(., function(ix){
    
    out_plot = suppressWarnings(
      opdesmixr:::plot_choice_set_utility(
        all_designs[[ix]]$design,
        utilities_cornell_bayesian_plot,
        utility_point_size = utility_point_size
      ) +
        ggtitle(
          paste0(
            all_designs[[ix]]$info$author, " ", all_designs[[ix]]$info$type_design, " ",
            "kappa = ", all_designs[[ix]]$info$kappa
          ),
          subtitle = paste0(
            "D-opt vale: ", round(all_designs[[ix]]$info$d_opt_value, 2),
            "    ",
            "I-opt vale: ", round(all_designs[[ix]]$info$i_opt_value, 2)
          )
        )
    )
    
    return(out_plot)
    
    
  })


# Couldn't get it to print with the list only

ggtern::grid.arrange(
  optimal_designs_plots[[1]],
  optimal_designs_plots[[2]],
  optimal_designs_plots[[3]],
  optimal_designs_plots[[4]],
  optimal_designs_plots[[5]],
  optimal_designs_plots[[6]],
  optimal_designs_plots[[7]],
  optimal_designs_plots[[8]],
  optimal_designs_plots[[9]],
  optimal_designs_plots[[10]],
  optimal_designs_plots[[11]],
  optimal_designs_plots[[12]],
  ncol = 3)



```















